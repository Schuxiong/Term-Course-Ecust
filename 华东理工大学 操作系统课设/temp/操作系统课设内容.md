# 课设内容:

## 实验考查

•（1）本实验的目的是通过一个简单多用户文件系统的设计，加深理解文件系统的内部功能和内部实现。

•（2）结合数据结构、程序设计、计算机原理等课程的知识，设计一个二级文件系统，进一步理解操作系统。

•（3）通过分对实际问题的分析、设计、编程实现，提高学生实际应用、编程的能力

## 实验要求

## •要求（模仿 Linux 的 EXT2 文件系统）

EXT2（Second Extended File System）是 Linux 系统中常用的文件系统之一，它是对早期的 EXT 文件系统进行了扩展和改进。EXT2 文件系统的原理和实现如下：

1. **数据结构**：
   - **超级块（Superblock）**：包含文件系统的基本信息，如总块数、每块大小、inode 数量等。
   - **inode（索引节点）**：描述文件或目录的元数据信息，包括文件大小、权限、所有者等。
   - **块组描述符（Block Group Descriptor）**：描述每个块组的信息，包括数据块位图、inode 位图等。
   - **数据块（Data Block）**：存储文件的实际内容。

2. **目录结构**：
   - EXT2 文件系统中的目录采用 B 树索引的结构，提高了目录的检索效率。
   - 每个目录项（Directory Entry）包含文件名和对应的 inode 号。

3. **数据存储**：
   - EXT2 文件系统使用块作为基本的存储单元，将磁盘空间划分为多个块组（Block Group），每个块组包含一定数量的数据块和 inode。
   - 数据块和 inode 分别使用位图进行管理，记录哪些块和 inode 已经被使用。

4. **文件读写**：
   - 文件系统通过 inode 索引文件的数据块，可以直接访问文件内容。
   - 对于小文件，EXT2 文件系统采用直接块指针（Direct Block Pointer）的方式存储文件内容；对于大文件，采用间接块指针（Indirect Block Pointer）或双间接块指针（Double Indirect Block Pointer）等方式进行存储。

5. **性能优化**：
   - EXT2 文件系统采用延迟写入（Delayed Allocation）等技术来提高文件系统的性能和稳定性。
   - 块组描述符表的使用减少了对磁盘的随机读写，提高了文件系统的性能。

EXT2 文件系统的实现是 Linux 内核中的一部分，通过调用相应的系统调用来进行文件操作。在内核中，有专门的文件系统模块负责对 EXT2 文件系统进行管理和操作。

–理解和掌握EXT2 文件系统的原理和实现；

–使用二进制文件来模拟磁盘空间，所有用户信息、inode 信息、超级块信息、文件信息均以二进制方式保存；

–可以实现下列几条命令：login、 dir、create、delete、open、 close、read、write等命令

–列目录时要列出文件名，物理地址，保护码和文件长度

–源文件可以进行读写保护（读写权限）

## 设计思路

![image-20240423222816360](C:\Users\74140\AppData\Roaming\Typora\typora-user-images\image-20240423222816360.png)

### 相关概念:

•Superblock(超级块)：存放文件系统本身的结构信息，例如：bolck 和 inode的总量，未使用的block和inode的数量，block和inode的大小……。

•Group Description Table(组描述符)：用来描述每个 组的开始与结束位置的块号码，以及说明每个块分别介于哪一个 block 号码之间。

•Block bitmap(块位图)：记录哪个数据块已经被占用，哪个数据块没有被占用。

•Inode bitmap(inode 位图)：记录的是使用与未使用的 inode 号。

•Inode table(inode 表)：存放着所有文件的 inode信息。

•Data Blocks(数据块)：来存放文件内容

## Index节点中存储信息:

•文件的读写权限(rwx)

•文件的拥有者和所属组(owner/group)

•文件的容量该文件的 ctime(创建时间)

•文件的 atime(最近一次的读取时间)

•文件的 mtime(最近修改的时间)

•文件真正内容的指向（ 12个直接 + 1个间接 + 个双间接 + 1个三间接记录区）

## 细节考查:

### 如何用二进制保存信息:

模拟磁盘空间并以二进制文件方式保存文件系统信息需要进行以下步骤：

1. **设计数据结构**：
   - 定义用户信息结构体，包括用户名、密码等信息。
   - 定义inode信息结构体，包括文件名、文件大小、文件权限等信息。
   - 定义超级块信息结构体，包括磁盘大小、inode数量、块大小等信息。
   - 定义文件信息结构体，包括文件名、文件内容等信息。

2. **存储结构设计**：
   - **使用二进制文件来模拟磁盘空间**，**可以将磁盘空间划分为多个块**，**每个块的大小为固定值**。
   - **将超级块信息存储在磁盘的第一个块中**。
   - 紧接着超级块存储inode信息，**依次排列在磁盘的后续几个块中**。
   - 用户信息可以存储在一个单独的块中，也可以分布存储在多个块中。
   - 文件信息则根据inode信息中的指针分散存储在磁盘的不同块中。

3. **读写操作**：
   - 对于每个数据结构，设计相应的读写函数，**负责将数据结构的内容写入到二进制文件中**，或者从二进制文件中读取内容到数据结构中。
   - 对于磁盘的读写操作，可以通过文件操作函数来实现，读取或写入指定位置的数据块。

4. **文件系统操作**：
   - 设计文件系统操作函数，包括创建文件、删除文件、打开文件、关闭文件等操作。
   - **在进行文件系统操作时，首先需要读取超级块信息，获取磁盘的相关参数，然后根据需要读取或修改相应的inode信息和文件内容。**

5. **权限控制**：
   - 在实现文件系统操作时，要考虑权限控制，即检查用户的权限是否允许进行指定操作，如读取文件、写入文件等。

6. **异常处理**：
   - 在进行读写操作时，要考虑异常情况的处理，如磁盘空间不足、文件不存在等情况，设计相应的错误处理机制。

通过以上步骤，可以实现一个模拟磁盘空间的文件系统，并以二进制文件的方式保存文件系统信息。

### 命令的实现思路:

1. **login**：
   - 用户输入用户名和密码。
   - 程序通过循环遍历预先设定的用户列表，逐个匹配输入的用户名和密码。
   - 如果匹配成功，则返回登录成功的标志，否则提示用户重新输入。

2. **dir**：
   - 遍历当前目录的子文件和子目录。
   - 输出每个文件或目录的名称、地址等信息。

3. **create**：
   - 用户输入新建文件的名称。
   - 程序检查当前目录下是否已经存在同名文件，如果存在则提示用户文件已存在，否则继续。
   - 用户输入文件内容。
   - 程序创建新的文件节点，并将文件内容写入文件节点中。

4. **delete**：
   - 用户输入要删除的文件或目录名称。
   - 程序检查当前目录下是否存在要删除的文件或目录。
   - 如果存在，则删除对应的文件或目录节点，并释放内存。

5. **open**：
   - 用户输入要打开的文件名称。
   - 程序检查当前目录下是否存在要打开的文件。
   - 如果存在，则将文件的打开标志设为打开状态。

6. **close**：
   - 用户输入要关闭的文件名称。
   - 程序检查当前目录下是否存在要关闭的文件。
   - 如果存在，则将文件的打开标志设为关闭状态。

7. **read**：
   - 用户输入要读取的文件名称。
   - 程序检查当前目录下是否存在要读取的文件。
   - 如果存在且文件为打开状态，则输出文件的内容。

8. **write**：
   - 用户输入要写入内容的文件名称。
   - 程序检查当前目录下是否存在要写入内容的文件。
   - 如果存在且文件为打开状态，则用户输入要写入的内容，并将内容写入文件节点中。

这些命令的实现思路基本上都是根据用户输入的命令进行相应的判断和操作，然后对文件系统进行相应的修改或查询。

## 实现列出目录时包括文件名、物理地址、保护码和文件长度

可以按照以下步骤进行：

1. **定义文件信息结构体**：包括文件名、物理地址、保护码和文件长度等字段。

```cpp
struct FileInfo {
    char filename[10];
    char address[10];
    char protect[10];
    int length;
};
```

2. **遍历目录**：设计函数用于遍历当前目录下的所有文件和子目录，获取它们的文件信息。

```cpp
void listDirectory() {
    // 遍历当前目录下的文件和子目录
    fnode* t = recent->child;
    while (t != NULL) {
        // 如果是文件，则输出文件信息
        if (!t->isdir) {
            FileInfo fileInfo;
            strcpy(fileInfo.filename, t->filename);
            strcpy(fileInfo.address, t->address);
            strcpy(fileInfo.protect, t->protect);
            fileInfo.length = t->leng;
            // 输出文件信息
            cout << fileInfo.filename << "  " << fileInfo.address << "  " << fileInfo.protect << "  " << fileInfo.length << endl;
        }
        t = t->next;
    }
}
```

3. **调用函数输出目录信息**：在需要列出目录时调用上述函数即可输出目录下所有文件的信息。

```cpp
// 示例代码中的 dir() 函数可以调用 listDirectory() 函数来输出目录信息
void dir() {
    listDirectory();
}
```

通过以上步骤，就可以实现列出目录时包括文件名、物理地址、保护码和文件长度的功能。

## 权限保护

实现文件的读写保护（权限控制）可以通过为文件信息结构体中添加权限字段，并在相应的操作函数中进行权限检查来实现。以下是一种简单的实现思路：

1. **修改文件信息结构体**：在文件信息结构体中添加读写权限字段。

```cpp
struct FileInfo {
    char filename[10];
    char address[10];
    char protect[10];
    int length;
    bool readPermission;
    bool writePermission;
};
```

2. **在文件创建函数中设置权限**：在创建文件时，设置文件的默认读写权限。

```cpp
fnode* initfile(char* filename, int isdir, bool readPermission, bool writePermission) {
    fnode* t;
    t = new fnode;
    strcpy(t->filename, filename);
    t->isdir = isdir;
    t->isopen = 0;
    t->parent = t->child = t->prev = t->next = NULL;
    t->leng = 0;
    t->readPermission = readPermission;
    t->writePermission = writePermission;
    return t;
}

// 在调用 initfile 函数时，设置默认的读写权限
fnode* t = initfile(filename, 0, true, true); // 示例中设置了默认的读写权限为 true
```

3. **在读写操作函数中进行权限检查**：在读写文件的函数中，先检查文件的读写权限，然后再执行读写操作。

```cpp
int write() {
    fnode* t;
    char filename[8];
    cin >> filename;
    if (recent->child == NULL) {
        cout << "文件不存在" << endl;
        return 1;
    } else {
        t = recent->child;
        do {
            if (strcmp(t->filename, filename) == 0 && t->isdir == 0) {
                // 检查写权限
                if (t->writePermission) {
                    // 执行写入操作
                    // ...
                } else {
                    cout << "无写权限，无法进行写入操作" << endl;
                }
                return 1;
            } else if (t->next)
                t = t->next;
            else {
                cout << "文件不存在" << endl;
                return 1;
            }
        } while (1);
    }
}

int read() {
    fnode* t;
    char filename[8];
    cin >> filename;
    if (recent->child == NULL) {
        cout << "文件不存在" << endl;
        return 1;
    } else {
        t = recent->child;
        do {
            if (strcmp(t->filename, filename) == 0 && t->isdir == 0) {
                // 检查读权限
                if (t->readPermission) {
                    // 执行读取操作
                    // ...
                } else {
                    cout << "无读权限，无法进行读取操作" << endl;
                }
                return 1;
            } else if (t->next)
                t = t->next;
            else {
                cout << "文件不存在" << endl;
                return 1;
            }
        } while (1);
    }
}
```

通过以上方式，在文件的创建时设置读写权限，并在读写操作函数中进行权限检查，就可以实现文件的读写保护。

# 系统实现

系统以下几个功能模块：

1. **用户管理模块**：
   - `struct usr` 结构体定义了用户的用户名和密码。
   - `login(char* username, char* password)` 函数用于验证用户输入的用户名和密码是否匹配。

2. **文件系统结构模块**：
   - `struct fnode` 结构体定义了文件或目录的结构，包括文件名、内容、地址、保护码等信息。
   - `initfile(char* filename, int isdir)` 函数用于初始化文件或目录结构。
   - `creatroot()` 函数用于建立根目录。
   - `mkdir()` 函数用于新建目录。
   - `create()` 函数用于新建文件。
   - `dir()` 函数用于列出当前目录中的文件和目录。
   - `write()` 函数用于写入文件。
   - `read()` 函数用于读取文件。
   - `cd()` 函数用于打开目录。
   - `del()` 函数用于删除文件或目录。
   - `open()` 函数用于打开文件。
   - `close()` 函数用于关闭文件。

3. **命令解析和执行模块**：
   - `run()` 函数作为文件系统的主函数，负责接受用户输入的命令并执行相应的操作。

4. **辅助函数模块**：
   - `help()` 函数用于显示命令帮助信息。

5. **主函数模块**：
   - `main()` 函数是程序的入口，用于用户登录和文件系统的初始化。

通过将代码拆分为这些功能模块，可以提高代码的可维护性和可扩展性，每个模块都有清晰的责任和功能，易于理解和修改。



## 用户管理模块

负责处理用户的登录功能，主要包括用户信息的定义和验证用户身份的功能。下面是对用户管理模块的详细分析：

### 1. 用户信息结构体定义：
```cpp
struct usr {
    char username[8], password[8];
};
```
- `usr` 结构体定义了用户的用户名和密码，每个用户有一个用户名和对应的密码。

### 2. 登录函数：
```cpp
int login(char* username, char* password) {
    for (int i = 0; i < 4; i++) {
        if (strcmp(username, users[i].username) == 0 && strcmp(password, users[i].password) == 0) {
            cout << "登陆成功！请输入命令" << endl;
            return 1; // 返回 1 表示登录成功
        }
    }
    return 0; // 返回 0 表示登录失败
}
```
- `login` 函数接受用户输入的用户名和密码作为参数，并与预先定义的用户信息进行匹配。
- 使用 `strcmp` 函数比较用户名和密码是否与预先定义的用户信息匹配。
- 如果用户名和密码匹配成功，则打印登录成功的消息并返回 1，表示登录成功；否则返回 0，表示登录失败。

### 功能说明：
- 用户管理模块提供了用户登录的功能，验证用户输入的用户名和密码是否与预先定义的用户信息匹配。
- 如果登录成功，允许用户访问文件系统的其他功能；如果登录失败，要求用户重新输入用户名和密码。
- 用户管理模块的设计简单明了，通过结构体保存用户信息，登录函数则遍历用户信息数组进行验证，实现了基本的用户认证功能。



## **文件系统结构模块**：

文件系统结构模块包含了与文件和目录相关的数据结构定义以及对其操作的函数。让我们逐一分析这些部分：

### 1. 文件和目录的数据结构定义：
- `struct fnode`：该结构体定义了文件或目录的属性。
  - `char filename[10]`：存储文件或目录的名称。
  - `char content[1024]`：存储文件的内容。
  - `char address[10]`：存储文件或目录的地址。
  - `char protect[10]`：存储文件的保护码。
  - `int isdir`：标记该节点是否为目录（1 表示是目录，0 表示是文件）。
  - `int isopen`：标记文件是否处于打开状态。
  - `int leng`：存储文件内容的长度。
  - `fnode* parent, *child, *prev, *next`：指针分别指向父节点、子节点、前一个兄弟节点和下一个兄弟节点。

### 2. 文件和目录的操作函数：
- `initfile(char* filename, int isdir)`：初始化文件或目录结构。
- `creatroot()`：创建根目录。
- `mkdir()`：新建目录。
- `create()`：新建文件。
- `dir()`：列出当前目录中的文件和目录。
- `write()`：向文件写入内容。
- `read()`：读取文件内容。
- `cd()`：切换当前目录。
- `del()`：删除文件或目录。
- `open()`：打开文件。
- `close()`：关闭文件。

### 3. 函数说明：
- `initfile(char* filename, int isdir)` 函数用于初始化一个新的文件或目录节点，设置其属性，并返回指向该节点的指针。
- `creatroot()` 函数用于创建根目录，初始化文件系统的根节点。
- `mkdir()` 和 `create()` 函数分别用于创建目录和文件，它们会在当前目录下创建新的节点，并更新相关的链表指针。
- `dir()` 函数用于列出当前目录下的所有文件和子目录。
- `write()` 和 `read()` 函数分别用于向文件写入内容和读取文件内容。
- `cd()` 函数用于切换当前目录，支持相对路径和绝对路径。
- `del()` 函数用于删除文件或目录，释放相应的节点并更新链表指针。
- `open()` 和 `close()` 函数分别用于打开和关闭文件，设置文件的打开状态。

这些函数构成了文件系统结构模块，负责管理文件和目录的创建、删除、读写等操作，实现了基本的文件系统功能。





## 命令解析和执行模块

负责接受用户输入的命令，并根据命令执行相应的操作。在这段代码中，这一模块由 `run()` 函数实现。让我们详细分析这个模块的功能：

### 1. `run()` 函数：

```cpp
int run() {
    char command[10];
    cout << "Linux:" << para << ">";
    cin >> command;
    if (strcmp(command, "help") == 0)
        help();
    else if (strcmp(command, "mkdir") == 0)
        mkdir();
    else if (strcmp(command, "create") == 0)
        create();
    else if (strcmp(command, "dir") == 0)
        dir();
    else if (strcmp(command, "write") == 0)
        write();
    else if (strcmp(command, "read") == 0)
        read();
    else if (strcmp(command, "cd") == 0)
        cd();
    else if (strcmp(command, "del") == 0)
        del();
    else if (strcmp(command, "open") == 0)
        open();
    else if (strcmp(command, "close") == 0)
        close();
    else if (strcmp(command, "quit") == 0)
        return 0;
    else
        cout << "请参考help提供的命令列表" << endl;
}
```

### 分析：

- **接受用户输入命令**：首先，函数显示当前所在路径，并提示用户输入命令。
- **解析命令**：使用 `cin` 读取用户输入的命令，并存储在 `command` 数组中。
- **根据命令执行相应操作**：通过一系列的 `if-else` 语句，根据用户输入的命令执行相应的操作。
- **命令执行**：根据用户输入的命令调用相应的函数进行操作，比如新建目录、新建文件、写入文件、读取文件、切换目录等。
- **退出系统**：如果用户输入 `quit` 命令，则返回 `0`，表示退出系统。
- **错误提示**：如果用户输入了未知的命令，通过 `else` 语句提示用户参考帮助信息。

这个模块将用户的命令与相应的操作对应起来，并且通过调用其他功能模块的函数来执行这些操作。



## 辅助函数模块：

1. **help() 函数**：
   - 功能：显示命令帮助信息，列出可用的命令列表。
   - 实现：通过输出字符串的方式，将各个命令及其功能说明显示在控制台上。

## 主函数模块：

1. **main() 函数**：
   - 功能：程序的入口，实现用户登录和文件系统的初始化。
   - 实现：
     - 输出欢迎信息和用户登录提示。
     - 获取用户输入的用户名和密码。
     - 调用 `login()` 函数验证用户名和密码，若验证成功则继续，否则要求用户重新输入。
     - 若验证成功，调用 `creatroot()` 函数建立根目录，并进入主循环。
     - 主循环中调用 `run()` 函数，等待用户输入命令并执行相应的操作。
     - 如果用户输入 "quit" 命令，则退出主循环，程序结束。

通过这样的设计，主函数模块负责整个程序的流程控制，包括用户登录验证、文件系统初始化以及命令执行等操作。辅助函数模块中的 help() 函数提供了用户使用命令时的帮助信息，增强了用户友好性。