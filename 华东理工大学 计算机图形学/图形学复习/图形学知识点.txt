计算机图形学是研究用计算机 输入，生成，存储，显示，输出 图形的一门学科

构成图形的要素：几何要素，非几何要素

图形在计算机中的表示：点阵法 参数法

相关领域：数字图形处理；模式识别；计算机视觉；计算机辅助几何设计

图像处理：数字图像与数据模型的转化

CRT图形显示器：随机扫描，直视存储，光栅扫描


绘制流水线的基本结构包括三个阶段：应用程序阶段，几何阶段，光栅阶段

应用-（模型与视点变换-光照-投影-裁剪-屏幕映射）-光栅阶段

分辨率：是水平分辨率  垂直分辨率  

亮度等级：单色显示器的亮度变化

帧缓冲存储器：显存

颜色查找表：调色板

光点：是指电子书打在显示器的 能显示发光点

像素点：是指图形显示分辨率能最小提供的元素点

屏幕分辨率（光栅分辨率）：通常用水平方向上的光点数与垂直方向上的光点数乘积

图形的存储分辨率值帧缓冲区的大小，一般用缓冲区的字节数表示


多边形包含性检验：夹角之和为0，点p在多边形之外
夹角和为360 在多边形之内

扫描线算法取整规则：检查两个端点与交点的值，看大于的点的个数即可

射线法：偶数在外，奇数在内

活性边也称有效边

区域填充：是从指从区域内的某一个像素点开始扩充到整个区域内

区域：指已经表示成点阵形式的填充图形，互通的像素集合

四连通和八连通种子填充法

多边形扫描转换与区域填充方法相比：
同：都是光栅图形面着色，用于真实感图形显示，可以相互转换
异：基本思想：前者点阵表示顶点，后者只改变区域内填充颜色。 边界要求：前者只要求多边形交点个数为偶数，后者要求区域封闭。 基本条件：前者从边界顶点信息触发后者从区域内种子点开始算法。

走样：用离散表示连续量引起的失真称之为走样

反走样：消除走样，提高分辨率，简单区域取样。

图形的几何变换：指对图形的几何信息经过平移，比例，旋转等，变换后产生的信息 是图形在方向尺寸和形状方面的变换。

基本集合变换：都是相对于坐标原点和坐标轴进行的几何变换。

窗口Window：在用户坐标系中需要进行观察和处理的一个坐标区域称为窗口

视区viewport：将窗口映射到显示设备上的坐标区域称为视区。

Sutherland-hodgeman 多边形裁剪：分而治之

变换种类：
视图变换（指定观察者或者摄影机的位置）
，模型变换（场景中移动对象）
，模型视图变换（视图变换与模型变幻的对偶性）
，投影变换（对视见空间进行修剪和改变大小）
，视见区变换（对窗口的最终输出进行缩放）

透视投影：汇聚到灭点

基本图形元素：图素或者图元，体素（段是素的集合）

Bezier曲线的性质：对称性，凸包性，几何不变性，差变减少性，控制顶点变化对曲线形状的影响。

消隐：
图像空间消隐算法
景物空间消隐算法
深度排序算法 区域细分算法 光线投射算法
基本原则：排序 连贯性


OpenGL：
主要功能
模型绘制 模型观察 颜色模式 光照应用 图像效果增强 位图和图像处理 纹理映射 实时动画 交互技术

相关库：
核心库：gl
实用程序库：glu
编程辅助库：aux
实用程序工具包：glut
Windows专用库：wgl

交互：可用glut实现 ；交互键盘，鼠标，菜单，拾取

点的绘制：
glBegins(GL_POINTS);
glVertex3f(0.0f,0.0f,0.0f);
glVertex3f(0.0f,0.0f,0.0f);
glEnd();

直线的绘制：
属性：线宽
void glLineWidth（GLfloat width）
线型
glEnable（GL_LINE_STIPPLE）；
glLineStipple（GLint factor ，GLushort pattern）；

三角形面的绘制：
GL_TRIANGLES
GL_TRIANGLE_STRIP
GL_TRIANGLE_STRIP

四边形面的绘制：
GL_QUADS
GL_QUADS_STRIP

多边形面的绘制：
GL_POLYGON

多边形面的法向量
void glNormal3{bisdf}（TYPE nx，TYPE ny ，TYPE nz）
void glNormal3{bisdf} v （const TYPE* v）；

实体模型：
实体或者线框球面：
void glutSolidSphere （GLdouble radius，GLint slices，GLint stacks）；

实体或者线框圆锥面：
void glutSolidCone （GLdouble radius，GLdouble height，GLint slices，GLint Stacks ）；

绘制实体或者线框圆环
void glutSolidTorus（GLdouble innerRadius， GLdouble outerRadius ，GLint Slice ，GLint stacks）

Glut位图字符
void glutBitmapCharacter （void *font，int character）

GLUT矢量字符：
void glutStrokeCharacter（void *font，int character）

平移
void glTranslated（f）

旋转
void glRotated（f）

比例
void glScaled（f）

视图变换函数：
void gluLookAt （）

矩阵操作：
glMatrixMode （）
确定那个矩阵用于矩阵操作

单位矩阵：
glTranslatef（）
glutSolidSphere（）
glMatrixMode（）
glLoadIdentity（）//单位矩阵置于堆栈顶部

矩阵堆栈：
void glPushMatrix（）
void GLPopMatrix（）

投影变换：
glMAtrixMode（）
glLoadIdentity（）

平行投影： glOrtho（）

透视投影：glFrustum（）
对称透视景体： gluPerspective（）



思考题
1．什么是“扫描转换”？一般什么时候需要扫描转换？
计算机图形学中的"扫描转换"（Scan Conversion）是指将图形或几何对象从其数学表示（如线段、多边形等）转换为屏幕上的像素表示的过程。这个过程通常涉及到将几何对象的坐标映射到屏幕坐标，并确定每个像素是否属于图形对象。
通常情况下，扫描转换在以下情况下需要进行：
1. 图形渲染：当需要在计算机屏幕上绘制图形，如线段、多边形、文本等时，需要将这些几何对象的数学表示转换为像素表示，以便在屏幕上显示出来。
2. 光栅化：光栅化是将矢量图形转换为栅格或像素表示的过程。这是计算机图形学中的一项基本任务，它需要对图形对象进行扫描转换，以确定哪些像素需要着色，以创建最终的图像。
3. 像素级操作：在一些图形处理任务中，需要对像素级的数据进行操作，例如图像处理、图像编辑和计算机视觉任务。扫描转换是将几何数据映射到像素级数据的关键步骤。
4. 图形交互：在交互式计算机图形应用中，用户通常可以在屏幕上进行绘制、移动和编辑图形。扫描转换帮助确定用户的操作如何影响图形的像素表示。
扫描转换的具体过程通常包括将几何对象的坐标映射到屏幕坐标系统、确定哪些像素包含在几何对象内部或边界上，以及根据需要进行颜色填充或着色。这个过程可以使用各种算法和技术来执行，以实现高效的图形渲染和处理。



1．Liang-Barsky的核心思想是什么？
Liang-Barsky 算法是一种用于线段裁剪的算法，其核心思想是通过对直线段进行参数化，将裁剪区域与直线段的交点进行比较，从而确定直线段是否在裁剪区域内部，以及如何进行裁剪。该算法的主要步骤包括参数化直线段、计算交点、判断交点位置、裁剪判定和裁剪。
具体来说，
	参数化直线段：将直线段表示为参数 t 的方程，通常形式为 \( P(t) = P_1 + t \cdot (P_2 - P_1) \)，其中 \( P_1 \) 和 \( P_2 \) 是直线段的端点。
	计算交点：计算直线与裁剪窗口边界的交点，得到参数 t 的值。
	判断交点位置： 检查交点的参数 t 值，确定其在裁剪窗口的位置。
	裁剪判定：判定直线段是否需要进行裁剪，根据交点的位置和裁剪窗口的位置关系，确定是否保留、舍弃或部分保留直线段。
	裁剪： 根据裁剪的判定结果，对直线段进行相应的裁剪。
Liang-Barsky 算法的优点在于它通过参数化直线段，通过比较交点位置，减少了计算量，提高了裁剪效率。

1．透视投影和平行投影的用途在哪里？
透视投影和平行投影是计算机图形学中两种不同的投影方式，它们在不同的场景和应用中有不同的用途。
1透视投影：
  用途：（1）仿真真实世界的视觉效果： 透视投影模拟了人眼观察远近物体时的视觉效果。远处的物体看起来较小，而近处的物体看起来较大。这种效果使得图形看起来更加自然和逼真。
     （2）艺术和娱乐领域：在游戏、电影和虚拟现实等领域中，透视投影用于创建具有深度感和逼真感的场景。
     （3）建筑和工程可视化： 透视投影有助于更好地理解建筑和工程模型，因为它提供了深度感，使观察者能够感知不同物体之间的距离。


2. 平行投影：
   用途： 
    计算机辅助设计（CAD）： 平行投影常用于CAD系统中，以确保设计的精确性。
     二维游戏和图形界面设计：在一些二维图形应用中，平行投影可以简化图形处理，而不引入透视效果。

选择透视投影或平行投影取决于应用的需求和所追求的视觉效果。透视投影适用于那些希望模拟真实世界观察效果的应用，而平行投影适用于那些需要保持物体比例和尺寸的应用。


1．Bezier曲线好不好用（优缺点）？
优： 灵活性：Bezier曲线以其出色的灵活性而著称，通过调整控制点，轻松创建各种曲线形状，包括直线、曲线、圆弧等。 数学简洁：Bezier曲线的数学表达式相对简单，易于理解和实现。 平滑性：Bezier曲线通常表现出良好的平滑性，尤其是三次Bezier曲线，其二阶导数连续。因此，在图形和设计领域得到广泛应用。
 缺： 控制点数量：在高阶Bezier曲线中，控制点的数量急剧增加，可能导致曲线的编辑和管理变得复杂。 局限性：在某些情况下，特别是处理复杂曲线或曲面时，Bezier曲线可能无法精确拟合一些特定形状。 直观性：当需要确保曲线通过一系列特定点时，相较于其他曲线插值方法，Bezier曲线插值的直观性较差。 

	优点： Realism（逼真度）: 光线追踪能够模拟真实光线的传播，反射，折射等现象，因此能够产生高度逼真的图像。 Global Illumination（全局光照）: 光线追踪可以有效地模拟全局光照效果，包括间接光照、环境光等，使得场景的照明更为真实。 适用于复杂场景： 光线追踪对于复杂场景中的光影效果表现更出色，特别是在处理镜面反射、折射、阴影等方面。 
	缺点： 计算成本高: 光线追踪是一个计算密集型任务，需要大量的计算资源。对于实时应用（如视频游戏），性能要求可能难以满足。 需要高度优化: 实现高质量的光线追踪往往需要深厚的数学知识和算法优化，对开发者的技能水平有较高要求。 实时交互性较差: 光线追踪通常需要较长的计算时间，导致实时交互性较差。这在需要快速渲染的应用场景中可能不适用。 

着色器是在图形渲染中用于计算每个像素最终颜色的程序。它们在图形管线的不同阶段执行，并影响图像的最终外观。以下是一些着色器的关键要点：

1. **顶点着色器(Vertex Shader)**:
   - 接收顶点作为输入。
   - 可以执行顶点的空间变换，例如将顶点从模型坐标系变换到屏幕坐标系。
   - 通常用于执行光照计算，为每个顶点计算光照效果。

2. **片段着色器(Fragment Shader)**:
   - 在光栅化阶段之后，对每个像素执行。
   - 决定最终的像素颜色。
   - 可以执行纹理映射，光照计算，阴影效果等。
   - 用于实现图形效果，如模糊、阴影、反射等。

3. **几何着色器(Geometry Shader)**:
   - 在顶点着色器之后，片段着色器之前执行。
   - 用于处理几何形状的整体信息，而不仅仅是单个顶点。
   - 可以用于生成新的几何形状，例如几何细分、法向量计算等。

4. **像素着色器(Pixel Shader)**:
   - 通常是指片段着色器。
   - 计算每个像素的最终颜色。
   - 用于实现纹理贴图、光照计算、阴影等。

5. **着色器语言**:
   - 着色器通常使用特定的编程语言编写，例如GLSL(OpenGL Shading Language)、HLSL(High-Level Shading Language)等。
   - 这些语言提供了丰富的内建函数和语法，用于执行图形渲染所需的计算。

6. **Uniforms 和 Attributes**:
   - Uniforms 是在渲染过程中保持不变的全局变量，由应用程序传递给着色器。
   - Attributes 是每个顶点独有的变量，描述顶点的属性。

7. **光照和阴影**:
   - 着色器通常用于实现光照模型，包括环境光、漫反射光、镜面反射光等。
   - 阴影效果也是通过着色器实现的，通常使用深度信息计算。

8. **纹理映射**:
   - 着色器可用于执行纹理映射，将纹理应用于几何表面，以增强外观。

9. **特效和后处理**:
   - 着色器广泛用于实现特效和后处理效果，如模糊、色彩校正、抗锯齿等。

10. **并行性**:
   - 着色器运行在GPU上，可以利用并行计算的优势，提高图形渲染的性能。


．程序中使用freeglut、glew、glfw、glad库的各自作用是什么？
	freeglut: freeglut是OpenGL的开源工具包，提供了一些方便的函数用于创建窗口、处理输入事件以及管理OpenGL上下文。它的目的是简化OpenGL应用程序的开发，使得开发者能够更专注于图形渲染而不用过多关心窗口和输入的处理。 
	glew: glew是一个用于管理OpenGL扩展的库。它简化了在程序中使用OpenGL扩展的过程，使得开发者能够更方便地访问和使用OpenGL的新功能。 
	glfw: glfw是一个轻量级的开源库，提供了创建窗口、处理用户输入、管理OpenGL上下文等功能。它设计简洁而强大，适用于OpenGL和Vulkan等图形API。
	 glad: glad是一个用于加载OpenGL函数指针的库，使得开发者能够在运行时动态获取OpenGL函数的地址。这对于使用OpenGL的扩展和新版本的功能非常有用，因为它们可能在不同的平台和驱动中有所不同。 
2.利用着色器实现光线追踪的优缺点？ 
	优点： Realism（逼真度）: 光线追踪能够模拟真实光线的传播，反射，折射等现象，因此能够产生高度逼真的图像。 Global Illumination（全局光照）: 光线追踪可以有效地模拟全局光照效果，包括间接光照、环境光等，使得场景的照明更为真实。 适用于复杂场景： 光线追踪对于复杂场景中的光影效果表现更出色，特别是在处理镜面反射、折射、阴影等方面。 
	缺点： 计算成本高: 光线追踪是一个计算密集型任务，需要大量的计算资源。对于实时应用（如视频游戏），性能要求可能难以满足。 需要高度优化: 实现高质量的光线追踪往往需要深厚的数学知识和算法优化，对开发者的技能水平有较高要求。 实时交互性较差: 光线追踪通常需要较长的计算时间，导致实时交互性较差。这在需要快速渲染的应用场景中可能不适用。 

